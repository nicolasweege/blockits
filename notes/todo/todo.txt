//
// @OBS:
// @TODO:
// @TODO @Incomplete:
// @TODO @Complete:
//

cascadia code - fonte pra talvez colocar no jogo ao inves da karmina que é paga, mas talvez 
eu pague pela karmina.

//
# LINKS
https://www.youtube.com/watch?v=TrP2Y18k1NE
https://www.youtube.com/watch?v=GlK5zM0xEpo
https://manual.gamemaker.io/monthly/en/index.htm#t=GameMaker_Language%2FGML_Reference%2FDrawing%2FPrimitives%2FPrimitives_And_Vertex_Formats.htm
https://manual.gamemaker.io/monthly/en/Settings/Included_Files.htm
https://forum.gamemaker.io/index.php?threads/gm-s-memory-management-101-tricks-and-clarity-sprite_add.35850/
https://forum.gamemaker.io/index.php?threads/loading-data-and-files.92899/
https://gist.github.com/JujuAdams/4b0f8839335df48f520c63f5ef58dc8e
//

- colocar todas as sprites e sons no included files, e carregar todos os assets quando iniciar o jogo
(verificar se isso é viavel, e se melhora consideravelmente o tempo de build).
- se for viavel usar apenas assets do included files, fazer com que todos eles, principalmente as sprites, 
sejam carregadas no início do jogo, usando batching.
- a mesma coisa pra audio, e também verificar qual o formato de arquivo que melhor se encaixa, 
talvez só precisamos usar .wav files.
- mesma coisa pra sprites, se for melhor usar apenas .bmp files, vamos usar.
- mesma coisa pra .json, eu sei que eles são bem lentos pra ler, então se existir algum outro formato 
de arquivo que de pra ler com as funções do gamemaker e for mais rápido, usaremos. Caso não tenha, 
vamos usar .txt mesmo, vai dar um pouco mais de trabalho mas é melhor do que usar .json.

- Lidar com os failure points de leitura de arquivos de uma forma mais segura, e mesmo que o jogo 
crashe, o save não será perdido. Isso serve pra qualquer load de arquivos pra dentro ou fora do jogo 
(principalmente os saves), é claro que funções de debug não precisam ser prioridade nesse quesito, 
já que não vão lançar com o exe final.
- cuidar de exceptions do gamemaker, principalmente quando tenta fazer load de algum arquivo externo, 
como assets, etc. (Esses são fail points que precisam ser tratados).

- ver como usar .dll no gamemaker, e ver pra que isso será util.

- melhorar gizmos de desenho pra debug dentro do jogo.

- implementar input recorder (apenas pra teclado e gamepad, não tem necessidade de incluir o mouse).
- se funcionar, implementar replay input.
- se tudo isso der certo, implementar testes automatizados (igual os que o Jonathan Blow faz no sokoban), 
e adicionar opções pra rodar esses testes por dentro do editor in-game.

- criar uma room de teste e tentar alterar o arquivo de metadata dela (.yy) pra salvar alterações que 
seriam feitar pelo editor in-game.
- criar outros assets pra fazer esse mesmo teste, como objects, sprites e notes.
- se esses testes derem certo, tentar implementar uma fucnionalidade que permita criar/salvar/carregar 
anotações em áreas específicas da room dentro do editor (pra deixar observações em levels que precisem 
ser alterador mais tarde, etc).

- depois de conseguir implementar tudo isso, talvez... e só talvez... de pra tentar implementar 
uma funcionalidade pra selecionar objetos da room com o mouse quando estiver no editor in-game. 
Daria até pra selecionar vários objetos de uma vez só segurando Ctrl ou desenhando uma área selecionável 
com o mouse, igual na área de trabalho do windows.

- lembrando que não é necessário pensar muito sobre performance nessas implementações, visto que nenhuma 
delas será lançada com o jogo, são só pra ajudar no processo de desenvolvimento. Contanto que esteja 
rodando a 60 fps ta de boa.

# PLAYER
- melhorar efeito de dash

# RM_JUNGLE
- foreground tiles
- backgroud tiles
- foreground props
- background props

# RM_LIBRARY
- foreground tiles
- backgroud tiles
- foreground props
- background props
- foreground / background particles - limitar melhor onde serao spawnadas

# RM_MOUNTAIN
cor dos bloom vignettes da mountain:                    0D0C19
old foreground_bloom_light color:                       red FF1952
cores das particulas de linhas horizontais na mountain: 19332D / 1E1D39 respectivamente

- foreground tiles
- backgroud tiles
- foreground props
- background props

# RM_PLAYGROUND
- levels da capsula

- correcao de cores
- foreground tiles
- backgroud tiles
- foreground props
- background props
- foreground / background particles

# RM_END
- plataformas de apenas um bloco; aparecem conforme o player se aproxima

# RM_WALL_DASH_COLLIDERS_BONUS
- levels

# RM_DESTROY_BLOCK_BONUS
- levels

# RM_LASER_BEAM_BONUS
- levels

# RM_CAPSULE_BONUS
- levels

- capsula liberada no final a area; player pode usa-la em outras areas

# RM_BONUS_1
- correcao de cores

# RM_BONUS_2
- correcao de cores

# CAPSULAS
- timer pra destruir o obj_capsule caso o player pare de se movimentar; obrigando o mesmo a movimentar-se
constantemente.

- capsula que eh detruida quando o player morre, e volta pra posicao inicial.

- capsula que nao eh destruida quando o player morre; o player pode deixar a capsula em um local,
e morrer propositalmente, pra usa-la depois.

- capsula que pode passar por dentro de um objeto solido especifico.

- duas capsulas que se movimentam somente nos eixos horizontal e vertical.

- capsula que segue movimentando-se na mesma direcao de quando o player saiu.

# DESTROY BLOCK
- implementar highlight do player quando dentro de um destroy block.

# LASER BEAM
- level use o obj_teleport_laser_beam pra teleportar o player em um local cheio de espinhos; proibindo
o uso do dash perto desse laser.

# IDEIAS
- objeto que gire os lasers em todas as direcoes; quando o player chega perto.

- objeto parecido com o andaime do minecraft.

- level que envolva usar o dash refill que acontece na transição da camera entre levels.

- adicionar animação com audio quando o player pousar em alguma superfice que não o deixe coletar
o obj_collectable.

- particulas que simulam pinceladas; pequenos rastros de pixels surgindo e desaparecendo suavemente.

- espinhos no geral (ou só em algumas áreas) podem ser animados, se movendo pra cima e pra baixo.